---
title: "TSQCA Tutorial (Japanese)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TSQCA Tutorial (Japanese)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# はじめに

TS-QCA（Threshold-Sweep QCA）は、crisp-set QCA において\
**アウトカム Y と条件 X の閾値設定が結果に与える影響を体系的に評価する**\
ためのフレームワークです。

QCA はキャリブレーション後、設定した閾値に基づいて\
データを 0/1 の集合に分けます。\
しかし、閾値が少し変わるだけで、Truth Table や最小化解が変化することがあります。

TS-QCA はその問題に対して、以下を自動実行します。

-   多数の閾値候補に基づくデータの二値化\
-   Truth Table の生成\
-   `QCA::minimize()` による最小化\
-   解（式・整合性・被覆値）の抽出

------------------------------------------------------------------------

# 実装されている4手法

TSQCA パッケージでは、TS-QCA の4つのスイープ手法を実装しています。

| 手法          | 変化させる閾値 | 固定する閾値 | 目的                   |
|---------------|----------------|--------------|------------------------|
| **CTS--QCA**  | 1つの X        | Y + 他の X   | 個別条件の影響を見る   |
| **MCTS--QCA** | 複数の X       | Y            | 複数条件の組合せの影響 |
| **OTS--QCA**  | Y              | 全ての X     | アウトカム閾値の影響   |
| **DTS--QCA**  | X と Y         | なし         | 全面的感度分析         |

> **対象範囲:** 本パッケージは**十分条件分析**に特化しています。必要条件分析（ある条件がアウトカムに必要かどうか）は異なる論理構造と評価指標を伴うため、将来のバージョンで対応予定です。

------------------------------------------------------------------------

# データ準備

TS-QCA は、キャリブレーション済みデータ（例：0〜10 スケール）を想定しています。\
閾値は数値（整数・実数）であれば構いません。

```{r}
# Adjust the file name as needed
library(TSQCA)
data("sample_data")
dat <- sample_data
str(dat)

Yvar  <- "Y"
Xvars <- c("X1", "X2", "X3")
```

※ 欠損値（NA）が含まれている場合、スイープ実行前に除去または補完を行ってください。

------------------------------------------------------------------------

# 混合データタイプの扱い

## 2値変数と連続変数が混在する場合

実際の社会科学データでは、**2値変数**（性別、Yes/No等）と**連続変数**（売上高、満足度スコア等）が混在することがよくあります。TSQCAでこのような混合データを扱う際には、以下の点に注意が必要です。

### 基本原則

1.  **2値変数に対して閾値スイープを行わない** --- すでに2値化されている（0/1）
2.  **2値変数には閾値 1 を指定**して元の値を保持する
3.  **`sweep_list`で各変数の閾値を明示的に定義**する

### なぜ2値変数には閾値1を指定するのか？

内部で使用される`qca_bin()`関数は `x >= thr` で2値化を行います：

-   `x = 0` の場合: `0 >= 1` → FALSE → **0**（元の値を保持）
-   `x = 1` の場合: `1 >= 1` → TRUE → **1**（元の値を保持）

これにより、2値変数は2値化プロセスで変更されることなく、元の値が保持されます。

### 実践例：混合データの場合

データセットに以下の変数があるとします：

-   **X1**: 性別（0 = 男性、1 = 女性）--- 2値変数
-   **X2**: 商品品質スコア（0-10）--- 連続変数
-   **X3**: 店舗雰囲気スコア（0-10）--- 連続変数

`ctSweepM()`を使用する場合：

```{r, eval=FALSE}
# 正しい方法：各変数の閾値を明示的に指定
sweep_list <- list(
  X1 = 1,      # 2値変数：閾値1で元の値を保持
  X2 = 6:8,    # 連続変数：閾値をスイープ
  X3 = 6:8     # 連続変数：閾値をスイープ
)

res_mixed <- ctSweepM(
  dat = dat,
  Yvar = "Y",
  Xvars = c("X1", "X2", "X3"),
  sweep_list = sweep_list,
  thrY = 7
)
```

これにより 1 × 3 × 3 = **9通り**の閾値組み合わせを探索し、X1は固定された2値条件として、X2とX3はスイープされます。

### よくある間違い

```{r, eval=FALSE}
# 間違い：2値変数に対してスイープ範囲を指定
sweep_list <- list(
  X1 = 6:8,    # すべての値が0になる（0 < 6 かつ 1 < 6 のため）
  X2 = 6:8,
  X3 = 6:8
)
```

誤って`X1 = 6:8`と指定すると、0も1も`>= 6`の条件を満たさないため、すべてのX1の値が0になってしまいます。これは2値変数の情報を完全に破壊してしまいます。

### 推奨方法

閾値スイープを設定する前に、必ずデータ構造を確認してください：

```{r, eval=FALSE}
# 変数の範囲を確認
summary(dat[, c("X1", "X2", "X3")])

# 2値変数を識別（0と1のみ）
sapply(dat[, c("X1", "X2", "X3")], function(x) {
  unique_vals <- sort(unique(x))
  if (length(unique_vals) == 2 && all(unique_vals == c(0, 1))) {
    "2値変数（閾値 = 1 を使用）"
  } else {
    paste("連続変数（範囲:", min(x), "-", max(x), ")")
  }
})
```

------------------------------------------------------------------------

# CTS--QCA（ctSweepS）：単一条件 X スイープ

CTS--QCA は、**1つの X 条件の閾値だけを変化させ**、\
Y とその他の X の閾値は固定したまま、結果の変化を確認する手法です。

```{r, error=TRUE}
sweep_var   <- "X3"   # 閾値を変化させる対象の条件（X）
sweep_range <- 6:9    # 試す閾値候補

thrY         <- 7     # Y の閾値（固定）
thrX_default <- 7     # その他 X の閾値（固定）

res_cts <- ctSweepS(
  dat            = dat,
  Yvar           = Yvar,
  Xvars          = Xvars,
  sweep_var      = sweep_var,
  sweep_range    = sweep_range,
  thrY           = thrY,
  thrX_default   = thrX_default,
  return_details = FALSE
)

head(res_cts)
```

------------------------------------------------------------------------

# MCTS--QCA（ctSweepM）：複数条件 X スイープ

MCTS--QCA は、**複数の X 条件の閾値を同時に変化させ**、\
すべての組合せに対して QCA を実行する手法です。

```{r, error=TRUE}
sweep_list <- list(
  X1 = 6:8,
  X2 = 6:8,
  X3 = 6:8
)

res_mcts <- ctSweepM(
  dat            = dat,
  Yvar           = Yvar,
  Xvars          = Xvars,
  sweep_list     = sweep_list,
  thrY           = 7,
  return_details = FALSE
)

head(res_mcts)
```

------------------------------------------------------------------------

# OTS--QCA（otSweep）：アウトカム Y のスイープ

OTS--QCA は、**アウトカム Y の閾値だけを変化させる**手法です。\
条件 X の閾値は固定したまま、Y の閾値の取り方が結果に与える影響を評価します。

```{r}
thrX <- c(X1 = 7, X2 = 7, X3 = 7)  # X の閾値（固定）

res_ots <- otSweep(
  dat            = dat,
  Yvar           = Yvar,
  Xvars          = Xvars,
  sweep_range    = 6:9,            # Y の閾値候補
  thrX           = thrX,
  return_details = FALSE
)

head(res_ots)
```

------------------------------------------------------------------------

# DTS--QCA（dtSweep）：X×Y 二次元スイープ

DTS--QCA は、**X の閾値（複数条件）と Y の閾値を同時に変化させる**\
最も包括的なスイープ手法です。

```{r}
# X 側の閾値候補（複数条件）
sweep_list_X <- list(
  X1 = 6:8,
  X2 = 6:8,
  X3 = 6:8
)

# Y 側の閾値候補
sweep_range_Y <- 6:8

res_dts <- dtSweep(
  dat            = dat,
  Yvar           = Yvar,
  Xvars          = Xvars,
  sweep_list_X   = sweep_list_X,   # X 側の閾値候補
  sweep_range_Y  = sweep_range_Y,  # Y 側の閾値候補
  return_details = FALSE
)

head(res_dts)
```

------------------------------------------------------------------------

# 出力の読み方

各スイープ関数の出力には、概ね次の情報が含まれます。

-   どの閾値を用いたか（X または Y の閾値）
-   その閾値のもとで得られた最小化解（`expression`）
-   解の整合性（`inclS`）
-   解の被覆値（`covS`）

一般的な解釈の目安：

-   **整合性（inclS）がおおよそ 0.8 以上**であれば、十分条件として望ましいとされることが多いです。\
-   **被覆値（covS）**は、その解がどの程度のケースを説明できているか（実質的な影響力）を示します。

※ 閾値をわずかに変えただけで最小化解が大きく変化する場合、\
その結果は閾値設定に敏感であり、ロバスト性に課題があると判断できます。

------------------------------------------------------------------------

# まとめ

TSQCA を用いることで、QCA における閾値設定の影響を体系的に評価し、\
分析結果のロバスト性を確認できます。

CTS / MCTS / OTS / DTS の各手法により、研究者は：

-   頑健な因果パターンの特定\
-   閾値に敏感な結果の検出\
-   分析全体の信頼性向上

を実現できます。

## References

For more information on TS-QCA methodology, see:

-   Ragin, C. C. (2008). *Redesigning Social Inquiry: Fuzzy Sets and Beyond*. University of Chicago Press. DOI: [10.7208/chicago/9780226702797.001.0001](https://doi.org/10.7208/chicago/9780226702797.001.0001)
-   Duşa, A. (2019). *QCA with R: A Comprehensive Resource*. Springer. DOI: [10.1007/978-3-319-75668-4](https://doi.org/10.1007/978-3-319-75668-4)
-   Oana, I.-E., & Schneider, C. Q. (2024). A Robustness Test Protocol for Applied QCA: Theory and R Software Application. *Sociological Methods & Research*, 53(1), 57--88. DOI: [10.1177/00491241211036158](https://doi.org/10.1177/00491241211036158)

# セッション情報

```{r}
sessionInfo()
```
